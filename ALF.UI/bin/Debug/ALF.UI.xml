<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ALF.UI</name>
    </assembly>
    <members>
        <member name="T:ALF.UI.EduUI.RegionTreeControl">
            <summary>
            RegionTreeControl.xaml 的交互逻辑
            </summary>
            <summary>
            RegionTreeControl
            </summary>
        </member>
        <member name="M:ALF.UI.EduUI.RegionTreeControl.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:ALF.UI.EduUI.RegionTreeControl.#ctor(ALF.MSSQL.DataModel.DataBaseEngineType,System.Int32,System.String,System.Boolean)">
            <summary>
            构造函数
            </summary>
            <param name="dataBaseEngineType">数据库引擎类型</param>
            <param name="recordYear">统计年份</param>
            <param name="dbName">数据库名称</param>
            <param name="showLogo">是否显示区划树上图标</param>
        </member>
        <member name="M:ALF.UI.EduUI.RegionTreeControl.Load(System.Int32,System.Boolean)">
            <summary>
            加载区划树
            </summary>
            <param name="type">加载类型</param>
            <param name="isLock">是否锁定</param>
        </member>
        <member name="M:ALF.UI.EduUI.RegionTreeControl.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="E:ALF.UI.EduUI.RegionTreeControl.SelectChange">
            <summary>
            选择改变事件
            </summary>
        </member>
        <member name="P:ALF.UI.EduUI.RegionTreeControl.AppType">
            <summary>
            选择类型
            </summary>
        </member>
        <member name="P:ALF.UI.EduUI.RegionTreeControl.SelectItem">
            <summary>
            选择节点
            </summary>
        </member>
        <member name="P:ALF.UI.EduUI.RegionTreeControl.SelectedPath">
            <summary>
            选择路径
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.CanBeNullAttribute">
            <summary>
            Indicates that the value of the marked element could be <c>null</c> sometimes,
            so the check for <c>null</c> is necessary before its usage.
            </summary>
            <example><code>
            [CanBeNull] public object Test() { return null; }
            public void UseTest() {
              var p = Test();
              var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
            }
            </code></example>
        </member>
        <member name="T:ALF.UI.Annotations.NotNullAttribute">
            <summary>
            Indicates that the value of the marked element could never be <c>null</c>.
            </summary>
            <example><code>
            [NotNull] public object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code></example>
        </member>
        <member name="T:ALF.UI.Annotations.ItemNotNullAttribute">
            <summary>
            Indicates that collection or enumerable value does not contain null elements.
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.ItemCanBeNullAttribute">
            <summary>
            Indicates that collection or enumerable value can contain null elements.
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.StringFormatMethodAttribute">
            <summary>
            Indicates that the marked method builds string by format pattern and (optional) arguments.
            Parameter, which contains format string, should be given in constructor. The format string
            should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>-like form.
            </summary>
            <example><code>
            [StringFormatMethod("message")]
            public void ShowError(string message, params object[] args) { /* do something */ }
            public void Foo() {
              ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
            }
            </code></example>
        </member>
        <member name="M:ALF.UI.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <param name="formatParameterName">
            Specifies which parameter of an annotated method should be treated as format-string
            </param>
        </member>
        <member name="T:ALF.UI.Annotations.ValueProviderAttribute">
            <summary>
            For a parameter that is expected to be one of the limited set of values.
            Specify fields of which type should be used as values for this parameter.
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one
            of the parameters of the caller function. For example, ReSharper annotates
            the parameter of <see cref="T:System.ArgumentNullException"/>.
            </summary>
            <example><code>
            public void Foo(string param) {
              if (param == null)
                throw new ArgumentNullException("par"); // Warning: Cannot resolve symbol
            }
            </code></example>
        </member>
        <member name="T:ALF.UI.Annotations.NotifyPropertyChangedInvocatorAttribute">
             <summary>
             Indicates that the method is contained in a type that implements
             <c>System.ComponentModel.INotifyPropertyChanged</c> interface and this method
             is used to notify that some property value changed.
             </summary>
             <remarks>
             The method should be non-static and conform to one of the supported signatures:
             <list>
             <item><c>NotifyChanged(string)</c></item>
             <item><c>NotifyChanged(params string[])</c></item>
             <item><c>NotifyChanged{T}(Expression{Func{T}})</c></item>
             <item><c>NotifyChanged{T,U}(Expression{Func{T,U}})</c></item>
             <item><c>SetProperty{T}(ref T, T, string)</c></item>
             </list>
             </remarks>
             <example><code>
             public class Foo : INotifyPropertyChanged {
               public event PropertyChangedEventHandler PropertyChanged;
               [NotifyPropertyChangedInvocator]
               protected virtual void NotifyChanged(string propertyName) { ... }
            
               private string _name;
               public string Name {
                 get { return _name; }
                 set { _name = value; NotifyChanged("LastName"); /* Warning */ }
               }
             }
             </code>
             Examples of generated notifications:
             <list>
             <item><c>NotifyChanged("Property")</c></item>
             <item><c>NotifyChanged(() =&gt; Property)</c></item>
             <item><c>NotifyChanged((VM x) =&gt; x.Property)</c></item>
             <item><c>SetProperty(ref myField, value, "Property")</c></item>
             </list>
             </example>
        </member>
        <member name="T:ALF.UI.Annotations.ContractAnnotationAttribute">
            <summary>
            Describes dependency between method input and output.
            </summary>
            <syntax>
            <p>Function Definition Table syntax:</p>
            <list>
            <item>FDT      ::= FDTRow [;FDTRow]*</item>
            <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
            <item>Input    ::= ParameterName: Value [, Input]*</item>
            <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
            <item>Value    ::= true | false | null | notnull | canbenull</item>
            </list>
            If method has single input parameter, it's name could be omitted.<br/>
            Using <c>halt</c> (or <c>void</c>/<c>nothing</c>, which is the same)
            for method output means that the methos doesn't return normally.<br/>
            <c>canbenull</c> annotation is only applicable for output parameters.<br/>
            You can use multiple <c>[ContractAnnotation]</c> for each FDT row,
            or use single attribute with rows separated by semicolon.<br/>
            </syntax>
            <examples><list>
            <item><code>
            [ContractAnnotation("=> halt")]
            public void TerminationMethod()
            </code></item>
            <item><code>
            [ContractAnnotation("halt &lt;= condition: false")]
            public void Assert(bool condition, string text) // regular assertion method
            </code></item>
            <item><code>
            [ContractAnnotation("s:null => true")]
            public bool IsNullOrEmpty(string s) // string.IsNullOrEmpty()
            </code></item>
            <item><code>
            // A method that returns null if the parameter is null,
            // and not null if the parameter is not null
            [ContractAnnotation("null => null; notnull => notnull")]
            public object Transform(object data) 
            </code></item>
            <item><code>
            [ContractAnnotation("s:null=>false; =>true,result:notnull; =>false, result:null")]
            public bool TryParse(string s, out Person result)
            </code></item>
            </list></examples>
        </member>
        <member name="T:ALF.UI.Annotations.LocalizationRequiredAttribute">
            <summary>
            Indicates that marked element should be localized or not.
            </summary>
            <example><code>
            [LocalizationRequiredAttribute(true)]
            public class Foo {
              private string str = "my string"; // Warning: Localizable string
            }
            </code></example>
        </member>
        <member name="T:ALF.UI.Annotations.CannotApplyEqualityOperatorAttribute">
            <summary>
            Indicates that the value of the marked type (or its derivatives)
            cannot be compared using '==' or '!=' operators and <c>Equals()</c>
            should be used instead. However, using '==' or '!=' for comparison
            with <c>null</c> is always permitted.
            </summary>
            <example><code>
            [CannotApplyEqualityOperator]
            class NoEquality { }
            class UsesNoEquality {
              public void Test() {
                var ca1 = new NoEquality();
                var ca2 = new NoEquality();
                if (ca1 != null) { // OK
                  bool condition = ca1 == ca2; // Warning
                }
              }
            }
            </code></example>
        </member>
        <member name="T:ALF.UI.Annotations.BaseTypeRequiredAttribute">
            <summary>
            When applied to a target attribute, specifies a requirement for any type marked
            with the target attribute to implement or inherit specific type or types.
            </summary>
            <example><code>
            [BaseTypeRequired(typeof(IComponent)] // Specify requirement
            public class ComponentAttribute : Attribute { }
            [Component] // ComponentAttribute requires implementing IComponent interface
            public class MyComponent : IComponent { }
            </code></example>
        </member>
        <member name="T:ALF.UI.Annotations.UsedImplicitlyAttribute">
            <summary>
            Indicates that the marked symbol is used implicitly (e.g. via reflection, in external library),
            so this symbol will not be marked as unused (as well as by other usage inspections).
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.MeansImplicitUseAttribute">
            <summary>
            Should be used on attributes and causes ReSharper to not mark symbols marked with such attributes
            as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="F:ALF.UI.Annotations.ImplicitUseKindFlags.Access">
            <summary>Only entity marked with attribute considered used.</summary>
        </member>
        <member name="F:ALF.UI.Annotations.ImplicitUseKindFlags.Assign">
            <summary>Indicates implicit assignment to a member.</summary>
        </member>
        <member name="F:ALF.UI.Annotations.ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature">
            <summary>
            Indicates implicit instantiation of a type with fixed constructor signature.
            That means any unused constructor parameters won't be reported as such.
            </summary>
        </member>
        <member name="F:ALF.UI.Annotations.ImplicitUseKindFlags.InstantiatedNoFixedConstructorSignature">
            <summary>Indicates implicit instantiation of a type.</summary>
        </member>
        <member name="T:ALF.UI.Annotations.ImplicitUseTargetFlags">
            <summary>
            Specify what is considered used implicitly when marked
            with <see cref="T:ALF.UI.Annotations.MeansImplicitUseAttribute"/> or <see cref="T:ALF.UI.Annotations.UsedImplicitlyAttribute"/>.
            </summary>
        </member>
        <member name="F:ALF.UI.Annotations.ImplicitUseTargetFlags.Members">
            <summary>Members of entity marked with attribute are considered used.</summary>
        </member>
        <member name="F:ALF.UI.Annotations.ImplicitUseTargetFlags.WithMembers">
            <summary>Entity marked with attribute and all its members considered used.</summary>
        </member>
        <member name="T:ALF.UI.Annotations.PublicAPIAttribute">
            <summary>
            This attribute is intended to mark publicly available API
            which should not be removed and so is treated as used.
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.InstantHandleAttribute">
            <summary>
            Tells code analysis engine if the parameter is completely handled when the invoked method is on stack.
            If the parameter is a delegate, indicates that delegate is executed while the method is executed.
            If the parameter is an enumerable, indicates that it is enumerated while the method is executed.
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.PureAttribute">
            <summary>
            Indicates that a method does not make any observable state changes.
            The same as <c>System.Diagnostics.Contracts.PureAttribute</c>.
            </summary>
            <example><code>
            [Pure] private int Multiply(int x, int y) { return x * y; }
            public void Foo() {
              const int a = 2, b = 2;
              Multiply(a, b); // Waring: Return value of pure method is not used
            }
            </code></example>
        </member>
        <member name="T:ALF.UI.Annotations.PathReferenceAttribute">
            <summary>
            Indicates that a parameter is a path to a file or a folder within a web project.
            Path can be relative or absolute, starting from web root (~).
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.SourceTemplateAttribute">
            <summary>
            An extension method marked with this attribute is processed by ReSharper code completion
            as a 'Source Template'. When extension method is completed over some expression, it's source code
            is automatically expanded like a template at call site.
            </summary>
            <remarks>
            Template method body can contain valid source code and/or special comments starting with '$'.
            Text inside these comments is added as source code when the template is applied. Template parameters
            can be used either as additional method parameters or as identifiers wrapped in two '$' signs.
            Use the <see cref="T:ALF.UI.Annotations.MacroAttribute"/> attribute to specify macros for parameters.
            </remarks>
            <example>
            In this example, the 'forEach' method is a source template available over all values
            of enumerable types, producing ordinary C# 'foreach' statement and placing caret inside block:
            <code>
            [SourceTemplate]
            public static void forEach&lt;T&gt;(this IEnumerable&lt;T&gt; xs) {
              foreach (var x in xs) {
                 //$ $END$
              }
            }
            </code>
            </example>
        </member>
        <member name="T:ALF.UI.Annotations.MacroAttribute">
            <summary>
            Allows specifying a macro for a parameter of a <see cref="T:ALF.UI.Annotations.SourceTemplateAttribute">source template</see>.
            </summary>
            <remarks>
            You can apply the attribute on the whole method or on any of its additional parameters. The macro expression
            is defined in the <see cref="P:ALF.UI.Annotations.MacroAttribute.Expression"/> property. When applied on a method, the target
            template parameter is defined in the <see cref="P:ALF.UI.Annotations.MacroAttribute.Target"/> property. To apply the macro silently
            for the parameter, set the <see cref="P:ALF.UI.Annotations.MacroAttribute.Editable"/> property value = -1.
            </remarks>
            <example>
            Applying the attribute on a source template method:
            <code>
            [SourceTemplate, Macro(Target = "item", Expression = "suggestVariableName()")]
            public static void forEach&lt;T&gt;(this IEnumerable&lt;T&gt; collection) {
              foreach (var item in collection) {
                //$ $END$
              }
            }
            </code>
            Applying the attribute on a template method parameter:
            <code>
            [SourceTemplate]
            public static void something(this Entity x, [Macro(Expression = "guid()", Editable = -1)] string newguid) {
              /*$ var $x$Id = "$newguid$" + x.ToString();
              x.DoSomething($x$Id); */
            }
            </code>
            </example>
        </member>
        <member name="P:ALF.UI.Annotations.MacroAttribute.Expression">
            <summary>
            Allows specifying a macro that will be executed for a <see cref="T:ALF.UI.Annotations.SourceTemplateAttribute">source template</see>
            parameter when the template is expanded.
            </summary>
        </member>
        <member name="P:ALF.UI.Annotations.MacroAttribute.Editable">
            <summary>
            Allows specifying which occurrence of the target parameter becomes editable when the template is deployed.
            </summary>
            <remarks>
            If the target parameter is used several times in the template, only one occurrence becomes editable;
            other occurrences are changed synchronously. To specify the zero-based index of the editable occurrence,
            use values >= 0. To make the parameter non-editable when the template is expanded, use -1.
            </remarks>>
        </member>
        <member name="P:ALF.UI.Annotations.MacroAttribute.Target">
            <summary>
            Identifies the target parameter of a <see cref="T:ALF.UI.Annotations.SourceTemplateAttribute">source template</see> if the
            <see cref="T:ALF.UI.Annotations.MacroAttribute"/> is applied on a template method.
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.AspMvcActionAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC action. If applied to a method, the MVC action name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.AspMvcAreaAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC area.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.AspMvcControllerAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is
            an MVC controller. If applied to a method, the MVC controller name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String, String)</c>.
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.AspMvcMasterAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC Master. Use this attribute
            for custom wrappers similar to <c>System.Web.Mvc.Controller.View(String, String)</c>.
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.AspMvcModelTypeAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC model type. Use this attribute
            for custom wrappers similar to <c>System.Web.Mvc.Controller.View(String, Object)</c>.
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.AspMvcPartialViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is an MVC
            partial view. If applied to a method, the MVC partial view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.RenderPartialExtensions.RenderPartial(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.AspMvcSupressViewErrorAttribute">
            <summary>
            ASP.NET MVC attribute. Allows disabling inspections for MVC views within a class or a method.
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.AspMvcDisplayTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC display template.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.Mvc.Html.DisplayExtensions.DisplayForModel(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.AspMvcEditorTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC editor template.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.EditorExtensions.EditorForModel(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.AspMvcTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC template.
            Use this attribute for custom wrappers similar to
            <c>System.ComponentModel.DataAnnotations.UIHintAttribute(System.String)</c>.
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.AspMvcViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view. If applied to a method, the MVC view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(Object)</c>.
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.AspMvcActionSelectorAttribute">
            <summary>
            ASP.NET MVC attribute. When applied to a parameter of an attribute,
            indicates that this parameter is an MVC action name.
            </summary>
            <example><code>
            [ActionName("Foo")]
            public ActionResult Login(string returnUrl) {
              ViewBag.ReturnUrl = Url.Action("Foo"); // OK
              return RedirectToAction("Bar"); // Error: Cannot resolve action
            }
            </code></example>
        </member>
        <member name="T:ALF.UI.Annotations.RazorSectionAttribute">
            <summary>
            Razor attribute. Indicates that a parameter or a method is a Razor section.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.WebPages.WebPageBase.RenderSection(String)</c>.
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.CollectionAccessAttribute">
            <summary>
            Indicates how method invocation affects content of the collection.
            </summary>
        </member>
        <member name="F:ALF.UI.Annotations.CollectionAccessType.None">
            <summary>Method does not use or modify content of the collection.</summary>
        </member>
        <member name="F:ALF.UI.Annotations.CollectionAccessType.Read">
            <summary>Method only reads content of the collection but does not modify it.</summary>
        </member>
        <member name="F:ALF.UI.Annotations.CollectionAccessType.ModifyExistingContent">
            <summary>Method can change content of the collection but does not add new elements.</summary>
        </member>
        <member name="F:ALF.UI.Annotations.CollectionAccessType.UpdatedContent">
            <summary>Method can add new elements to the collection.</summary>
        </member>
        <member name="T:ALF.UI.Annotations.AssertionMethodAttribute">
            <summary>
            Indicates that the marked method is assertion method, i.e. it halts control flow if
            one of the conditions is satisfied. To set the condition, mark one of the parameters with 
            <see cref="T:ALF.UI.Annotations.AssertionConditionAttribute"/> attribute.
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.AssertionConditionAttribute">
            <summary>
            Indicates the condition parameter of the assertion method. The method itself should be
            marked by <see cref="T:ALF.UI.Annotations.AssertionMethodAttribute"/> attribute. The mandatory argument of
            the attribute is the assertion type.
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.AssertionConditionType">
            <summary>
            Specifies assertion type. If the assertion method argument satisfies the condition,
            then the execution continues. Otherwise, execution is assumed to be halted.
            </summary>
        </member>
        <member name="F:ALF.UI.Annotations.AssertionConditionType.IS_TRUE">
            <summary>Marked parameter should be evaluated to true.</summary>
        </member>
        <member name="F:ALF.UI.Annotations.AssertionConditionType.IS_FALSE">
            <summary>Marked parameter should be evaluated to false.</summary>
        </member>
        <member name="F:ALF.UI.Annotations.AssertionConditionType.IS_NULL">
            <summary>Marked parameter should be evaluated to null value.</summary>
        </member>
        <member name="F:ALF.UI.Annotations.AssertionConditionType.IS_NOT_NULL">
            <summary>Marked parameter should be evaluated to not null value.</summary>
        </member>
        <member name="T:ALF.UI.Annotations.TerminatesProgramAttribute">
            <summary>
            Indicates that the marked method unconditionally terminates control flow execution.
            For example, it could unconditionally throw exception.
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.LinqTunnelAttribute">
            <summary>
            Indicates that method is pure LINQ method, with postponed enumeration (like Enumerable.Select,
            .Where). This annotation allows inference of [InstantHandle] annotation for parameters
            of delegate type by analyzing LINQ method chains.
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.NoEnumerationAttribute">
            <summary>
            Indicates that IEnumerable, passed as parameter, is not enumerated.
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.RegexPatternAttribute">
            <summary>
            Indicates that parameter is regular expression pattern.
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.XamlItemsControlAttribute">
            <summary>
            XAML attribute. Indicates the type that has <c>ItemsSource</c> property and should be treated
            as <c>ItemsControl</c>-derived type, to enable inner items <c>DataContext</c> type resolve.
            </summary>
        </member>
        <member name="T:ALF.UI.Annotations.XamlItemBindingOfItemsControlAttribute">
            <summary>
            XAML attibute. Indicates the property of some <c>BindingBase</c>-derived type, that
            is used to bind some item of <c>ItemsControl</c>-derived type. This annotation will
            enable the <c>DataContext</c> type resolve for XAML bindings for such properties.
            </summary>
            <remarks>
            Property should have the tree ancestor of the <c>ItemsControl</c> type or
            marked with the <see cref="T:ALF.UI.Annotations.XamlItemsControlAttribute"/> attribute.
            </remarks>
        </member>
        <member name="T:ALF.UI.Annotations.NoReorder">
            <summary>
            Prevents the Member Reordering feature from tossing members of the marked class.
            </summary>
            <remarks>
            The attribute must be mentioned in your member reordering patterns
            </remarks>
        </member>
        <member name="T:ALF.UI.TitleCombo">
            <summary>
            TitleCombo.xaml 的交互逻辑
            </summary>
            <summary>
            TitleCombo
            </summary>
        </member>
        <member name="M:ALF.UI.TitleCombo.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:ALF.UI.TitleCombo.SetBinding">
            <summary>
            设置绑定
            </summary>
        </member>
        <member name="M:ALF.UI.TitleCombo.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="P:ALF.UI.TitleCombo.Title">
            <summary>
            标题
            </summary>
        </member>
        <member name="P:ALF.UI.TitleCombo.TitleWidth">
            <summary>
            标题区域宽度
            </summary>
        </member>
        <member name="P:ALF.UI.TitleCombo.ValueWidth">
            <summary>
            值区域宽度
            </summary>
        </member>
        <member name="P:ALF.UI.TitleCombo.TitleColor">
            <summary>
            标题颜色
            </summary>
        </member>
        <member name="P:ALF.UI.TitleCombo.TitleSize">
            <summary>
            标题大小
            </summary>
        </member>
        <member name="P:ALF.UI.TitleCombo.IsEnable">
            <summary>
            是否启用
            </summary>
        </member>
        <member name="P:ALF.UI.TitleCombo.Binding">
            <summary>
            绑定属性名称
            </summary>
        </member>
        <member name="P:ALF.UI.TitleCombo.SelectedItem">
            <summary>
            所选对象
            </summary>
        </member>
        <member name="P:ALF.UI.TitleCombo.SelectedIndex">
            <summary>
            所选序号
            </summary>
        </member>
        <member name="P:ALF.UI.TitleCombo.ItemsSource">
            <summary>
            绑定数据源
            </summary>
        </member>
        <member name="P:ALF.UI.TitleCombo.Items">
            <summary>
            数据源字符串
            </summary>
        </member>
        <member name="P:ALF.UI.TitleCombo.DisplayMemberPath">
            <summary>
            显示属性名称
            </summary>
        </member>
        <member name="E:ALF.UI.TitleCombo.SelectionChanged">
            <summary>
            选择改变事件处理
            </summary>
        </member>
        <member name="T:ALF.UI.TitleLabel">
            <summary>
            TitleLabel.xaml 的交互逻辑
            </summary>
            <summary>
            TitleLabel
            </summary>
        </member>
        <member name="M:ALF.UI.TitleLabel.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:ALF.UI.TitleLabel.SetBinding">
            <summary>
            设置绑定
            </summary>
        </member>
        <member name="M:ALF.UI.TitleLabel.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="P:ALF.UI.TitleLabel.Title">
            <summary>
            标题
            </summary>
        </member>
        <member name="P:ALF.UI.TitleLabel.TitleWidth">
            <summary>
            标题区域宽度
            </summary>
        </member>
        <member name="P:ALF.UI.TitleLabel.ValueWidth">
            <summary>
            值区域宽度
            </summary>
        </member>
        <member name="P:ALF.UI.TitleLabel.TitleColor">
            <summary>
            标题颜色
            </summary>
        </member>
        <member name="P:ALF.UI.TitleLabel.TitleSize">
            <summary>
            标题大小
            </summary>
        </member>
        <member name="P:ALF.UI.TitleLabel.Binding">
            <summary>
            绑定属性名称
            </summary>
        </member>
        <member name="P:ALF.UI.TitleLabel.Value">
            <summary>
            值
            </summary>
        </member>
        <member name="P:ALF.UI.TitleLabel.ValueBackground">
            <summary>
            值背景颜色
            </summary>
        </member>
        <member name="T:ALF.UI.TitleTextBox">
            <summary>
            TitleText.xaml 的交互逻辑
            </summary>
            <summary>
            TitleTextBox
            </summary>
        </member>
        <member name="M:ALF.UI.TitleTextBox.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:ALF.UI.TitleTextBox.SetBinding">
            <summary>
            设置绑定
            </summary>
        </member>
        <member name="M:ALF.UI.TitleTextBox.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="P:ALF.UI.TitleTextBox.Title">
            <summary>
            标题
            </summary>
        </member>
        <member name="P:ALF.UI.TitleTextBox.TitleWidth">
            <summary>
            标题区域宽度
            </summary>
        </member>
        <member name="P:ALF.UI.TitleTextBox.ValueWidth">
            <summary>
            值区域宽度
            </summary>
        </member>
        <member name="P:ALF.UI.TitleTextBox.TitleColor">
            <summary>
            标题颜色
            </summary>
        </member>
        <member name="P:ALF.UI.TitleTextBox.TitleSize">
            <summary>
            标题大小
            </summary>
        </member>
        <member name="P:ALF.UI.TitleTextBox.Binding">
            <summary>
            绑定属性名称
            </summary>
        </member>
        <member name="P:ALF.UI.TitleTextBox.IsLong">
            <summary>
            是否长字符串
            </summary>
        </member>
        <member name="P:ALF.UI.TitleTextBox.Value">
            <summary>
            值
            </summary>
        </member>
        <member name="P:ALF.UI.TitleTextBox.ValueBackground">
            <summary>
            值背景颜色
            </summary>
        </member>
        <member name="P:ALF.UI.TitleTextBox.IsReadonly">
            <summary>
            是否只读
            </summary>
        </member>
        <member name="P:ALF.UI.TitleTextBox.VanishBorder">
            <summary>
            是否显示边框
            </summary>
        </member>
    </members>
</doc>
